# #
# # Создайте класс Car с атрибутами make, model и year. Добавьте метод display_info(),
# # который выводит информацию о машине. Затем создайте объект этого класса и вызовите метод display_info().
# # Требования:
# # •	Программа должна создавать класс с названием Car, который содержит атрибуты make, model и year.
# # •	Класс Car должен содержать метод display_info(), который выводит информацию о машине.
# # •	Программа должна создавать объект класса Car.
# # •	Программа должна вызывать метод display_info() для объекта класса Car.
#
#
# class Car:
#     def __init__(self,make,model,year):
#         self.make=make
#         self.model = model
#         self.year = year
#
#     def display_info(self):
#         print(f"Марка: {self.make}, model: {self.model}, year: {self.year}")
#
#
# car1 = Car("Toyota", "Camry", 2015)
#
# car1.display_info()
from http.cookiejar import parse_ns_headers
from symtable import Class

# Создайте класс Library с атрибутом books, который представляет собой список книг.
# Добавьте методы add_book(book) для добавления книги в библиотеку и display_books() для вывода списка всех книг.
# Создайте объект класса Library, добавьте несколько книг и выведите список книг, используя методы объекта.
# Требования:
# •	Программа должна включать класс Library с атрибутом books, представляющим собой список книг.
# •	Класс Library должен содержать метод add_book(book), который добавляет книгу в список books.
# •	Класс Library должен содержать метод display_books(), который выводит список всех книг.
# •	Программа должна создавать объект класса Library.
# •	Программа должна использовать методы add_book(book) и display_books() на созданном объекте для добавления книг и вывода списка книг.


# class Library:
#     def __init__(self, books):
#         self.books = books
#
#     def add_book(self, name_book):
#         self.books.append(name_book)
#
#     def display_books(self):
#         print(f"Books: {self.books}")
#
#
# collection = Library([])
#
# collection.add_book("Harry Potter")
# collection.display_books()


# Создайте класс Rectangle с конструктором, который принимает параметры width и height.
# Добавьте метод area(), который возвращает площадь прямоугольника. Создайте объект этого класса и вычислите его площадь.
# Требования:
# •	Программа должна включать класс Rectangle, который содержит конструктор с параметрами width и height.
# # •	В классе Rectangle должен быть метод area(), который возвращает площадь прямоугольника, рассчитанную как произведение ширины и высоты.
# # •	Необходимо создать объект класса Rectangle с заданными шириной и высотой.
# # •	С помощью метода area() создаденного объекта необходимо вычислить и вывести площадь прямоугольника.
#
# class Rectangle:
#     def __init__(self, width, height):
#         self.width = width
#         self.height = height
#
#     def area(self):
#         print(self.width * self.height)
#
#
# rectangle1 = Rectangle(5, 10)
#
# rectangle1.area()
#
# class Rectangle:
#     def __init__(self, width, height):
#         self.width = width
#         self.height = height
#
#     def area(self):
#         return self.width * self.height
#
#
# rectangle1 = Rectangle(5, 10)
#
# print(rectangle1.area())
#
# Банкир.
# Создайте класс BankAccount с конструктором, который принимает параметры account_number и initial_balance.
# Добавьте метод deposit(amount), который пополняет счет, и метод withdraw(amount), который снимает средства со счета.
# Создайте объект этого класса и выполните несколько операций пополнения и снятия средств.
# Требования:
# •	Программа должна включать класс BankAccount, который имеет конструктор, принимающий параметры account_number и initial_balance.
# •	Класс BankAccount должен содержать метод deposit(amount), который увеличивает баланс счета на указанную сумму.
# •	Класс BankAccount должен иметь метод withdraw(amount), который уменьшает баланс счета на указанную сумму при условии наличия достаточных средств.
# •	Программа должна создать объект класса BankAccount и выполнить несколько операций по пополнению и снятию средств, демонстрируя работу методов deposit и withdraw.


# class BankAccount:
#     def __init__(self, account_number, initial_balance):
#         self.account_number = account_number
#         self.initial_balance = initial_balance
#
#     def deposit(self, amount):
#         self.initial_balance = self.initial_balance + amount
#         print(f"Остаток на счету {self.initial_balance}")
#
#     def withdraw(self, amount):
#         if self.initial_balance < amount:
#             print(f"Недостаточно средств, Остаток на счету {self.initial_balance}")
#         else:
#             self.initial_balance = self.initial_balance - amount
#             print(f"Остаток на счету {self.initial_balance}")
#
# account1 = BankAccount(123, 1500)
# account1.deposit(50)
# account1.withdraw(500)

# Создайте класс Car, который будет иметь публичный атрибут brand и защищенный атрибут _model_.
# Добавьте методы для получения и установки значения защищенного атрибута _model_.
# Создайте объект класса Car, установите значения атрибутов и выведите их на экран.
# Требования:
# •	Программа должна включать создание класса Car.
# •	Класс Car должен содержать публичный атрибут brand, который можно будет свободно изменять и читать.
# •	Класс Car должен содержать защищенный атрибут _model_, доступ к которому должен осуществляться через методы получения и установки значения.
# •	Класс Car должен содержать метод для получения значения защищенного атрибута _model_ и метод для установки значения защищенного атрибута _model_.
# •	Программа должна создать объект класса Car, установить значения атрибутов brand и _model_, используя публичные и защищенные методы доступа, и вывести эти значения на экран.
#
# class Car:
#     def __init__(self, brand, _model):
#         self.brand = brand
#         self._model = _model
#
#     def get_model(self):
#         return self._model
#
#     def set_model(self,_model):
#         self._model = _model
#
# car1 = Car("Toyota", "Rav4")
# car1.set_model("Prius")
# print(car1.get_model())
# print(car1.brand)

# Библиотека.
# Создайте класс Library, который будет представлять библиотеку книг.
# Добавьте метод __str__, который будет возвращать строку с информацией о библиотеке с перечнем книг,
# и метод __len__, который будет возвращать количество книг в библиотеке. Создайте объект класса Library,
# добавьте в него несколько книг и выведите информацию о библиотеке и количество книг.
# Требования:
# •	Программа должна включать класс Library, который представляет библиотеку книг.
# •	В классе Library должен быть метод __str__, который возвращает строковую информацию о библиотеке с перечнем книг.
# •	В классе Library должен быть метод __len__, который возвращает количество книг в библиотеке.
# •	Должна быть возможность добавлять книги в объект класса Library.
# •	Программа должна выводить информацию о библиотеке с перечнем книг и количество книг с использованием методов __str__ и __len__.

# class Library:
#     def __init__(self, *books):
#         self.books = list(books)
#
#     def lib_append(self, book_name):
#         self.books.append(book_name)
#
#     def __str__(self):
#         return f"Books: {self.books}"
#
#     def __len__(self):
#         return len(self.books)
# lib1 = Library("1994")
# lib1.lib_append("HP")
# print(lib1.__str__())
# print(lib1.__len__())


#
# Создайте базовый класс Vehicle, который будет иметь атрибуты brand и model.
# Затем создайте дочерний класс Car, который будет наследовать от Vehicle и добавлять атрибут fuel_type.
# Используйте метод super() для вызова конструктора базового класса.
# Требования:
# •	Программа должна включать базовый класс Vehicle, который содержит атрибуты brand и model.
# •	Программа должна включать дочерний класс Car, который наследует от базового класса Vehicle.
# •	Дочерний класс Car должен добавлять новый атрибут fuel_type.
# •	Конструктор дочернего класса Car должен использовать метод super() для вызова конструктора базового класса Vehicle.

#
# class Vehicle:
#     def __init__(self, brand, model):
#         self.brand = brand
#         self.model = model
#
# class Car(Vehicle):
#     def __init__(self, brand, model, fuel_type):
#         super().__init__(brand, model)
#         self.fuel_type = fuel_type

# Создайте базовый класс Animal с методом speak, который возвращает строку "Ррррр!".
# Затем создайте дочерний класс Dog, который будет наследовать от Animal и переопределять метод speak,
# добавляя к поведению родительского класса собственное поведение с использованием метода super().
# Требования:
# •	Программа должна включать базовый класс Animal, содержащий метод speak, который возвращает строку "Ррррр!".
# •	Программа должна включать дочерний класс Dog, который наследует от базового класса Animal.
# •	В дочернем классе Dog метод speak должен быть переопределен и использовать метод super() для включения поведения базового класса.
# •	Метод speak в дочернем классе Dog должен добавлять к строке "Ррррр!" собственное поведение (например, " Гав!").
#
# class Animal:
#     def speak(self):
#         return "ррррр!"
#
# class Dog(Animal):
#     def speak(self):
#         parent_speech = super().speak()
#         return  f"{parent_speech} Гав!"


# Напишите функцию check_type для проверки, является ли переданный объект экземпляром класса Animal или его подклассов.
# Используйте функцию isinstance() для выполнения проверки. Затем создайте классы Animal, Dog, Cat и проверьте несколько объектов.
# Требования:
# •	Программа должна включать определение класса Animal.
# •	Программа должна включать определение класса Dog, который является подклассом Animal.
# •	Программа должна включать определение класса Cat, который является подклассом Animal.
# •	Программа должна включать функцию check_type, которая использует isinstance() для проверки, является ли переданный объект экземпляром класса Animal или его подклассов.
# •	Программа должна проверять несколько объектов с помощью функции check_type и выводить результаты проверки.
#
# class Animal:
#     pass
#
# class Dog(Animal):
#     pass
#
# class Cat(Animal):
#     pass
#
# dog = Dog()
# cat = Cat()
#
# def check_type(*args):
#     print(isinstance(*args))
#
# check_type(dog,Dog)
# check_type(cat,Animal)

# Напишите функцию check_subclass для проверки, является ли один класс подклассом другого.
# Используйте функцию issubclass() для выполнения проверки. Затем создайте классы Vehicle, Car, Bicycle, и проверьте, являются ли Car и Bicycle подклассами Vehicle.
# Требования:
# •	Программа должна включать функцию под названием check_subclass, которая принимает два аргумента: два класса для проверки.
# •	Функция check_subclass должна использовать встроенную функцию issubclass() для проверки, является ли первый переданный в нее класс подклассом второго.
# •	Программа должна включать определение класса Vehicle.
# •	Программа должна включать определение класса Car, который представляет собой тип транспортного средства.
# •	Программа должна включать определение класса Bicycle, который представляет собой тип транспортного средства.

# class Vehicle:
#     pass
#
# class Car(Vehicle):
#     pass
#
# class Bicycle(Vehicle):
#     pass
#
# def check_subclass(*args):
#     print(issubclass(*args))
#
#
# check_subclass(Bicycle, Vehicle)
# check_subclass(Car, Bicycle)

#
# Создайте два базовых класса Base1 и Base2, каждый из которых имеет метод describe().
# Создайте производный класс Combined, который наследует от обоих базовых классов.
# Реализуйте метод describe() в каждом базовом классе. Вызовите метод describe() у объекта класса Combined.
# Требования:
# •	Программа должна включать два базовых класса — `Base1` и `Base2`.
# •	Каждый из базовых классов (`Base1` и `Base2`) должен содержать метод `describe()`.
# •	Программа должна включать производный класс `Combined`, который наследует от обоих базовых классов (`Base1` и `Base2`).
# •	Метод `describe()` должен быть вызван для объекта класса `Combined`.

# class Base1:
#     def describe(self):
#         print("base1")
#         super().describe()
#
#
# class Base2:
#     def describe(self):
#         print("base2")
#
#
#
# class Combined(Base1, Base2):
#     def describe(self):
#
#         super().describe()
#
# obj = Combined()
# obj.describe()


#
# Создайте два базовых класса BaseA и BaseB, каждый из которых имеет метод action().
# Создайте производный класс Derived с переопределенным методом action(), который вызывает метод super().action().
# Вызовите метод action() у объекта класса Derived и проанализируйте порядок вызова методов.
# Требования:
# •	Программа должна включать класс BaseA, который содержит метод action().
# •	Программа должна включать класс BaseB, который содержит метод action().
# •	Программа должна включать класс Derived, который наследуется от классов BaseA и BaseB и переопределяет метод action().
# •	Метод action() в классе Derived должен вызывать метод super().action().
# •	Программа должна создать объект класса Derived и вызвать у него метод action(), чтобы проанализировать порядок вызова методов.

# class BaseA:
#     def action(self):
#         print(1)
#         super().action()
#
# class BaseB:
#     def action(self):
#         print(2)
#
# class Derived(BaseA, BaseB):
#     def action(self):
#         print(3)
#         super().action()
#
# derived =Derived()
# derived.action()


#
# Создайте классы A, B, C, и D, где B и C наследуют от A, а D наследует от B и C.
# В каждом классе определите метод method, который выводит имя класса и вызывает метод super().method().
# Создайте экземпляр класса D и вызовите метод method, чтобы понять порядок вызова методов по MRO.
# Требования:
# •	Программа должна содержать классы A, B, C, и D, где классы B и C наследуют от класса A, а класс D наследует от классов B и C.
# •	Каждый класс должен иметь метод method, который выводит имя класса и вызывает метод super().method().
# •	Программа должна создавать экземпляр класса D.
# •	Программа должна вызывать метод method на экземпляре класса D, чтобы продемонстрировать порядок вызова методов по MRO (методу разрешения порядка).
# •	Метод method в каждом классе должен выводить имя соответствующего класса.

# class A:
#     def method(self):
#         print("A")
#
#
# class B(A):
#     def method(self):
#         print("B")
#         super().method()
#
# class C(A):
#     def method(self):
#         print("C")
#         super().method()
#
#
# class D(B,C):
#     def method(self):
#         print("D")
#         super().method()
#
# d = D()
# d.method()



# Создайте классы M, N, и O, где N и O наследуют от M.
# В каждом классе определите метод action, который выводит имя класса и вызывает метод родительского класса с помощью super().
# Проверьте порядок вызова методов, создав экземпляр класса N и вызвав метод action.
# Требования:
# •	Необходимо создать три класса с именами M, N и O. Классы N и O должны наследовать от класса M.
# •	В каждом из классов M, N и O необходимо определить метод с именем action. Метод должен выводить имя текущего класса.
# •	Методы action в классах N и O должны вызывать метод action родительского класса с помощью super().
# •	Необходимо создать экземпляр класса N и вызвать его метод action для проверки порядка вызова методов.

# class M:
#     def action(self):
#         print("M")
#
#
# class N(M):
#     def action(self):
#         print("N")
#         super().action()
#
# class O(M):
#     def action(self):
#         print("N")
#         super().action()
#
# n = N()
# n.action()


# Напишите функцию safe_division, которая принимает два числа и выполняет их деление.
# Обработайте исключения, которые могут возникнуть при делении на ноль и при передаче некорректных значений (например, строки вместо чисел).
# Функция должна возвращать сообщение об ошибке или результат деления.
# Требования:
# •	Функция safe_division должна обрабатывать исключение ZeroDivisionError, которое возникает при делении на ноль, и возвращать сообщение об ошибке.
# •	Функция safe_division должна обрабатывать исключение TypeError, которое возникает при передаче некорректных значений (например, строк вместо чисел),
# и возвращать соответствующее сообщение об ошибке.
# •	Функция safe_division должна возвращать результат деления в случае, если входные данные корректны и деление не на ноль.
# •	Функция должна иметь блок try-except, который корректно обрабатывает все возможные исключения, связанные с некорректным вводом и делением на ноль.

# def safe_division(a: int, b: int) ->int :
#     try:
#         result = a/b
#     except ZeroDivisionError:
#         return "Деление на ноль"
#     except TypeError:
#         return "Не верный тип данных"
#     else:
#         return f"Результат: {result}"
#
# safe_division(5, 5)

#
# Напишите функцию convert_and_sum, которая принимает два аргумента в виде строк, преобразует их в целые числа и возвращает их сумму.
# Обработайте исключения, которые могут возникнуть при преобразовании строк в числа (например, если переданы некорректные значения).
# В случае возникновения исключения, программа должна вернуть строку с указанием ошибки, например, "Некорректное значение".
# Требования:
# •	Программа должна включать функцию с именем convert_and_sum, которая принимает два аргумента в виде строк.
# •	Функция convert_and_sum должна преобразовывать переданные строки в целые числа.
# •	Функция convert_and_sum должна возвращать сумму двух преобразованных чисел.
# •	Функция convert_and_sum должна обрабатывать исключения, возникающие при преобразовании строк в целые числа, и корректно обрабатывать некорректные значения.

#
# def convert_and_sum(a: str, b: str) -> int | str :
#     try:
#         a = int(a)
#         b = int(b)
#         result = a+b
#     except ValueError:
#         return "Некорректное значение"
#     else:
#         return result



# Создайте модуль geometry.py, который содержит функции circle_area(radius) и
# rectangle_area(length, width).
# Затем импортируйте только функцию circle_area и используйте её в другом файле.
# Требования:
# •	Создать файл geometry.py, содержащий определения функций circle_area(radius)
# и rectangle_area(length, width).
# •	В файле geometry.py создать функцию circle_area(radius), которая принимает
# радиус и возвращает площадь круга.
# •	В файле geometry.py создать функцию rectangle_area(length, width), которая
# принимает длину и ширину и возвращает площадь прямоугольника.
# •	В другом файле выполнить импорт только функции circle_area из модуля geometry.
# •	В другом файле должна быть использована функция circle_area для вычисления
# площади круга.

#
# from geometry import circle_area
#
# radius = 5
# area = circle_area(radius)
# print(f"Площадь круга с радиусом {radius} равна {area}")


#
# Напишите программу, которая запрашивает у пользователя название модуля для импорта и имя функции для вызова из этого модуля.
# Программа должна динамически импортировать модуль и вызвать указанную функцию с любым аргументом.
# Для получения дочернего элемента у модуля используйте функцию getattr
# Требования:
# •	Программа должна запросить у пользователя ввод названия модуля, который необходимо будет импортировать.
# •	Программа должна запросить у пользователя ввод имени функции, которую необходимо будет вызвать из импортированного модуля.
# •	Программа должна импортировать модуль, введенный пользователем, используя встроенную функцию __import__.
# •	Программа должна использовать функцию getattr для получения функции из импортированного модуля по имени, введенному пользователем.
# •	Программа должна выполнить вызов полученной функции из импортированного модуля.
#
#
# module_name = input("Введите название модуля : ")
# module = __import__(module_name)
# func = input("Ведите название функции: ")
# print(getattr(module, func)(5))







